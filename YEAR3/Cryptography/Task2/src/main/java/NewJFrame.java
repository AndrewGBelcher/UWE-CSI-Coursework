/**
 * @title TASK 2: BCH 10,6 ERROR CHECKER
 * @author Andrew Belcher
 */
import java.math.BigInteger;


public class NewJFrame extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jTextField1 = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Error Correction Code");

        jButton1.setText("check");
        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton1MouseClicked(evt);
            }
        });

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 290, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(93, 93, 93)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(120, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(154, 154, 154)
                .addComponent(jLabel1)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(177, 177, 177)
                .addComponent(jButton1)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(78, 78, 78)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton1)
                .addGap(25, 25, 25)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(24, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * negates a number with regards to modular arithmetic
     * @param a the target number
     * @param mod modulo
     * @return the negative of the number modulated
     */
    public int negate(int a, int mod)
    {
   
        int tmp = -a % mod;
         
        if(tmp<0) 
            tmp+=mod;
        
        return tmp;
    }
    
    /**
     * inverts a number with regards to modular arithmetic
     * @param a the target number
     * @param mod modulo
     * @return the inverse of the number modulated
     */
    public int inverse(int a, int mod) 
    { 
        
    int t = 0; 
    int newt = 1; 
    int r = mod; 
    int newr = a;    
    int q, temp;  

    while(newr != 0) 
    { 
        q = r / newr;       
        temp = newt;   
        newt = t - q*newt;
        t = temp;
        temp = newr;  
        newr = r - q*newr;
        r = temp;
    } 
    
    if(r > 1) 
        return -1;
    
    if(t < 0) t = t + mod; 
        return t;
    }


    /**
     * finds the square root for a number with regards to modular arithmetic
     * @param n the target number
     * @param mod modulo
     * @return the square root
     */
    static int squareRoot(int n, int mod) 
    { 
        n = n % mod; 

        // One by one check all numbers 
        // from 2 to p-1 
        for (int x = 1; x < mod; x++) { 
            if ((x * x) % mod == n) { 
                return x; 
            } 
        } 
        return -1;
    } 

    /**
     * encodes a syndrome for BCH 10,6
     * @param d
     * @param mod modulo 
     * @return an array of the encoded syndrome
     */
    private int[] encodeSyn(int[] d, int mod)
    {
        int [] array = new int[10];

            //d7 = (4*d1+10*d2+9*d3+2*d4+d5+7*d6) mod 11 
            array[0]= (4 * d[0] +
                  10 * d[1] + 
                   9 * d[2] +
                   2 * d[3] +
                   d[4]     +
                   7 * d[5]
                   ) % mod;

            //d8 = (7*d1+8*d2+7*d3+d4+9*d5+6*d6) mod 11 
            array[1]= (7 * d[0] +
                   8 * d[1] + 
                   7 * d[2] +
                   d[3]     +
                   9 * d[4] +
                   6 * d[5]
                   ) % mod;

            //d9 = (9*d1+d2+7*d3+8*d4+7*d5+7*d6) mod 11 
            array[2]= (9 * d[0] +
                   d[1]     + 
                   7 * d[2] +
                   8 * d[3] +
                   7 * d[4] +
                   7 * d[5]
                   ) % mod;

            //d10 = (d1+2*d2+9*d3+10*d4+4*d5+d6) mod 11
            array[3] =(d[0]     +
                    2 * d[1] + 
                    9 * d[2] +
                   10 * d[3] +
                    4 * d[4] +
                    d[5]
                    ) % mod;

           return array;

    }

    /**
     * Decodes a syndrome for BCH 10,6
     * @param d
     * @param mod modulo
     * @return an array of the decoded syndrome
     */
    private int[] decodeSyn(int[] d, int mod)
    {
            int [] syn = new int[10];

            // s1= (d1+d2+d3+d4+d5+d6+d7+d8+d9+d10) mod 11
            for(int i=0; i<10; i++)
                syn[0] += d[i];
            syn[0] = syn[0]%mod;

            // s2= (d1+2*d2+3*d3+4*d4+5*d5+6*d6+7*d7+8*d8+9*d9
            // +10*d10) mod 11
            syn[1] = (d[0]+2 *
                    d[1]+3 *
                    d[2]+4 *
                    d[3]+5 *
                    d[4]+6 *
                    d[5]+7 *
                    d[6]+8 *
                    d[7]+9 *
                    d[8]+10 *
                    d[9])%mod;   

            //s3= (d1+4*d2+9*d3+5*d4+3*d5+3*d6+5*d7+9*d8
            // +4*d9+d10) mod 11

            syn[2]=(d[0] + 4 *
                    d[1] + 9 *
                    d[2] + 5 *
                    d[3] + 3 *
                    d[4] + 3 *
                    d[5] + 5 *
                    d[6] + 9 *
                    d[7] + 4 *
                    d[8] +
                    d[9]) % mod;

            // s4= (d1+8*d2+5*d3+9*d4+4*d5+7*d6+2*d7+6*d8
            // +3*d9+10*d10) mod 11

            syn[3]=(d[0] + 8 *
                    d[1] + 5 *
                    d[2] + 9 *
                    d[3] + 4 *
                    d[4] + 7 *
                    d[5] + 2 *
                    d[6] + 6 *
                    d[7] + 3 *
                    d[8] + 10 *
                    d[9]) % mod;   


            return syn;
    }

    /**
     * function for calculating A based on decoded syndromes and the correct calculation of b
     * @param syn an int array of the decoded syndrome values
     * @param b magnitude of error
     * @param mod modulo 
     * @return A based on the decoded syndromes and the correct magnitude of B
     */
    private int calcA(int[]syn, int b, int mod)
    {
        int result = syn[0] - b;

        if(result < 0)
            result = negate(~result+1,mod);

        return result;
    }


    /**
     * calculates b(magnitude) for the 2nd error detected in BCH 10,6
     * @param syn an int array of the decoded syndrome values
     * @param i error position
     * @param j error position
     * @param mod modulo
     * @return B based on syndromes and correct i/j values
     */
    private int calcB(int[]syn, int i, int j, int mod)
    {
        int tmp = i-j;
        int result;

        if(tmp < 0)
            tmp = negate(~tmp+1,mod);

        result = (negate(~(i*syn[0]-syn[1])+1,mod) * inverse(tmp,mod))%mod;

        if(result < 0)
            result = negate(~result+1,mod);

       // System.out.print("calcB: tmp is "+tmp+"\n"+"result is: "+result+ "\n");
        return result;
    }


    /**
     * function for calculating I(position) based on P Q and R being calculated correctly
     * @param p any int
     * @param q any int
     * @param r any int 
     * @param mod modulo
     * @return I based on pqr
     */
    private int calcI(int p, int q, int r, int mod)
    {
        int newQ = ~q+1;
        int z = ((q*q) - (4*p*r))%mod;

        if(z<0)
            z = negate(~z+1,mod);

        int tmp = squareRoot(z,mod);
        int x = (newQ + tmp)%mod;
        int y = (2*p)%11;

        int result = (negate(~x+1,mod) * inverse(y,mod))%mod;

        if(result < 0)
            result = negate(~result+1,mod);

        return result;
    }


    /**
     * function for calculating J(position) based on P Q and R being calculated correctly
     * @param p any int
     * @param q any int
     * @param r any int
     * @param mod modulo
     * @return J based on pqr
     */
    private int calcJ(int p, int q, int r, int mod)
    {
        int newQ = ~q+1;
        int z = ((q*q) - (4*p*r))%mod;

        if(z<0)
            z = negate(~z+1,mod);

        int tmp = squareRoot(z,mod);
        int x = (newQ - tmp)%mod;
        int y = (2*p)%mod;

        int result = (negate(~x+1,mod) * inverse(y,mod))%mod;

        if(result < 0)
            result = negate(~result+1,mod);

        return result;
    }

    
    // Process the BCH code and detect/resolve errors
    private void jButton1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton1MouseClicked
                
        int[] d = new int[10];
        int[] e = new int[10];
        int[] syn = new int[10];
        long out = 0; 
        int i_var = 0;
        int a_var = 0;
        int j_var = 0;
        int b_var = 0;
        int p,q,r = 0;
        int sqrt = 0;

        String s;
        
        jTextArea1.setText(""); // clear text everytime we run
        
        s = jTextField1.getText();
        
        // must be 10 chars long to be valid BCH 10,6
        if(s.length() != 10)
        {
            jTextArea1.setText("Please enter a 10 digit number"); 
            return; // get out before doing anything else
        }

        // parse the code to our array
        for (int i = 0; i < 10; i++) 
            d[i] = Integer.parseInt(String.valueOf(s.charAt(i)));

        // produce a decoded/encoded form of our syndromes to work with
        e = encodeSyn(d,11);
        syn = decodeSyn(d,11);


        // no error only when all decoded syndromes are clear
        if(syn[0]+syn[1]+syn[2]+syn[3]==0)
        {
            out = Long.parseLong(s);
            jTextArea1.setText("input:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                        " check:"+d[6]+d[7]+d[8]+d[9] + 
                        "\noutput: "+ out+
                        "\n"+"encoded syndromes: "+ e[0]+e[1]+e[2]+e[3] +"\n"+ 
                        "decoded syndromes: "+ syn[0]+" "+syn[1]+" "+syn[2]+" "+syn[3]+" "+
                        "\n\nno_error");
        }
        
        // enter various error states
        else
        {

            // Calculate p q and r and only negate if we get underflow
            p = (syn[1]*syn[1]-syn[0]*syn[2])%11;
            q = (syn[0]*syn[3]-syn[1]*syn[2])%11;
            r = (syn[2]*syn[2]-syn[1]*syn[3])%11;
            if(p < 0)p = negate(~p+1,11);
            if(q < 0)q = negate(~q+1,11);
            if(r < 0)r = negate(~r+1,11);

            // get square root under mod 11
            sqrt = ((q*q)-4*p*r)%11;
            if(sqrt < 0)sqrt = negate(~sqrt+1,11);
            sqrt = squareRoot(sqrt, 11);

            // setup I J B and A for error correction later
            i_var = calcI(p,q,r,11);
            j_var = calcJ(p,q,r,11);
            b_var = calcB(syn, i_var, j_var,11);
            a_var = calcA(syn, b_var,11);

            // the logic that determines if only one error exists
            if((p == 0 && q == 0 && r == 0) && 
               (i_var != 0 && j_var != 0) &&
               (syn[1]/syn[0]) != 0
              )
            {

                i_var = syn[1]/syn[0];
                a_var = syn[0];

                int[] tmp_out = new int[10];

                for(int m = 0; m < 10; m++)
                {
                    tmp_out[m] = d[m];
                    if(m == i_var-1)
                    {
                        tmp_out[m] = (tmp_out[m] - a_var)%11;
                        if(tmp_out[m]<0)
                            tmp_out[m] = negate(~tmp_out[m]+1,11);
                    }
                }

                jTextArea1.setText(
                      "input:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                      " check:"+d[6]+d[7]+d[8]+d[9] + "\n"+
                      "output:"+tmp_out[0]+tmp_out[1]+tmp_out[2]+tmp_out[3]+tmp_out[4]+tmp_out[5]+tmp_out[6]+tmp_out[7]+tmp_out[8]+tmp_out[9]+
                      "\nsingle_err(i=" + i_var + ",a="+a_var+",syn("+syn[0]+","+syn[1]+","+syn[2]+","+syn[3]+"))");


            }
            
            // error is either double or more than 2
            else
            {   
                // temp values used to verify a/b
                int check_a = 0;
                int check_b = 0;
                
                // produca a check and roll back if under
                if(i_var != 0)
                {
                    check_a = (d[i_var-1] - a_var)%11;
                    if(check_a<0)
                        check_a = negate(~check_a+1,11); 
                }

                // produca b check and roll back if under                
                if(j_var != 0)
                {
                    check_b = (d[j_var-1] - b_var)%11;
                    if(check_b<0)
                        check_b = negate(~check_b+1,11); 
                }
                
                //
                if(sqrt != -1 && (i_var != 0 && j_var != 0) && (check_a != 10 && check_b != 10) )
                {
                    int[] tmp_out = new int[10];

                    // loop through the original BCH 10,6
                    for(int m = 0; m < 10; m++)
                    {
                       // load our array for correction after
                       tmp_out[m] = d[m];
                       
                       // fix error position for I with magnitude of A
                       if(m == i_var-1)
                       {
                            tmp_out[m] = (tmp_out[m] - a_var)%11;
                            if(tmp_out[m]<0)
                                tmp_out[m] = negate(~tmp_out[m]+1,11); 
                       }
                       
                        // fix error position for I with magnitude of A
                       else if(m == j_var-1)
                       {
                            tmp_out[m] = (tmp_out[m] - b_var)%11;
                            if(tmp_out[m]<0)
                                tmp_out[m] = negate(~tmp_out[m]+1,11);
                       }
                    }

                    jTextArea1.setText(
                            "input:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                            " check:"+d[6]+d[7]+d[8]+d[9] + "\n"+
                            "output:"+tmp_out[0]+tmp_out[1]+tmp_out[2]+tmp_out[3]+tmp_out[4]+tmp_out[5]+tmp_out[6]+tmp_out[7]+tmp_out[8]+tmp_out[9]+
                            "\ndouble_err(i=" + i_var 
                                    + ",a="+a_var+",j=" 
                                    + j_var + ",b="
                                    + b_var + ",syn("
                                    + syn[0] + "," 
                                    + syn[1] + ","
                                    + syn[2] + ","
                                    + syn[3] + "),"
                                    + "pqr(" + p + ","+ q + "," + r + ")");

                }
                else
                {
                    jTextArea1.setText(
                            "input:"+d[0]+d[1]+d[2]+d[3]+d[4]+d[5]+
                            " check:"+d[6]+d[7]+d[8]+d[9] + "\n"+
                            "output:???"+
                            "\nencoded syndromes: "+ e[0]+" "+e[1]+" "+e[2]+" "+e[3] +" "+"\n"+        
                            "decoded syndromes: "+ syn[0]+" "+syn[1]+" "+syn[2]+" "+syn[3]+" "+
                            "\nmorethan2_no_sqrt(syn("+syn[0]+","+syn[1]+","+syn[2]+","+syn[3]+") "+ "pqr("+p+","+q+","+r+"))");       
                }
            }
        }    
    }//GEN-LAST:event_jButton1MouseClicked


    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables
}
